// Абстрактная фабрика — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.
// абстрактная фабрика - создать приложение для любой фабрики

// Легковес — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов
// между собой, вместо хранения одинаковых данных в каждом объекте.
// Например объект частица.Она имеет изменяемы во времени: вектор, скорость, координаты. При этом цвет, sprite у неё бует всегда одинаковый, вне зависимости от времени.
// Решение
// Создаем контект в котором эта частица используется и в контексте прописываем цвет чатицы, вес.
// Создали словарь из которого эта частица берется, и через словарь её используем
// Тут добавляем в словарь значение Rectangle и circle 1 раз. Далее смотрим, если есть в словаре есть Rectangle то просто идем дальше. 

// Наблюдатель — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.
// Аналог из жизни. Вы подписались на газету. Ездить узнавать в магазин, узнавать вышел ли новый номер газеты не надо. Вместо этого издательство ведет список подписчиков и знает кому какой
// журнал высылать. Вы можете в любой момент отказаться от подписки и журнал перестанет к вам приходить.
// проблема. Есть покупатель который хочет купить ноутбук определнной марки. Он может ходить каждый день в магазин и узнавать не появился ли этот ноутбук. Магазин может разослать спам что такой ноутбук
// появился всем, но не всем это будет интересно.
// Создатель предоставляет общий интерфейс для подписки. Плписчики сами подписываются на то или иное событие.

//Адаптер — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.
// В разных странах разные разетки. Чтобы зарядить телефон нужен адаптер.
// Пусть есть приложение которое скачивает и обрабатывает данные из xml. нам надо сделать так, чтобы оно работало и с json. Для этого вешаем адаптер на json и работаем так же. Сами json не переписываем

// Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.
// Пусть есть класс фигура. В ней есть квадрат, треугольник, круг. Также есть цвет красный синий. Цвет нужно вынести в отдельный класс  и работать в класе фигура только с объектом цвет.
// Мост позволяет вынести разные типы в отдельную иерархию, не связано друг с другом. Например класс завод vw. Его могул унаследовать skoda, audi, volkswagen. Тип трансмисии - отдельная иерархия. Цвет - отдельная
// иерархия

// Строитель — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово.
// Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.
// Допустим нам надо создать дом. Класс дом должен иметь сколько стен, оккон, какая крыша, какой бассейн и тд. Если это сделать передать это через конструктор, то будет не очень. Т.к. не все дома имеют
// бассейн и тд. 
// Паттерн предлагает разбить строительство дома на отельные части, которые выполняются только если они нужны. Т.е. в доме где нет бассейна, бассейн не будет создаваться, в отличие от того, если бы мы передавли через конструктор это все
// Дом можно создать из кирпича и дерева. Для этого нудны 2 класса строителей. При вызове шагов строительства получим разные результаты

//Цепочка обязанностей — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он
//обработать запрос сам и стоит ли передавать запрос дальше по цепи.
// Пример из жизни: звоним в мтс: сначала автоответчик предлагает выбрать 0-9 для того чтобы сделать что-то дальше. Затем трубку беретcall центр, если проблема сложная, то переводит в отдел инженеров,
// разработчиков 

// Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их,
// а также поддерживать отмену операций.
// Пример из жизни. Идем в ресторан, там официант записывает наш заказ. Далее официант идет на кухню, вырывает лист из блокнота и отдает его повару. Повар берет лист и готовит заказ. При
// этом повар не знает кто конкретно заказал а вы, "отправитель" не знаете кто конкретно будет готовить
// паттерн позволяет преобразовать запрос в отдельный объект-команду. Такая инкапсуляция позволяет передавать другим функциям в качестве параметра команду как объект(например официант передает лист с заказом). 
// storeAndExecute ф-ция как официант. Принимает объект интерфейса Icomand.

// Компоновщик — это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.
// Пусть есть класс продукт и коробка. В коробке может лежать продукт или коробка поменьше. В коробке поменьше тоже может лежать продукт и т.д. Нужно расчитать стоимость всего заказа: продукты,коробки
// Если решать прямо - надо посмотреть в каждую коробку, узнать стоимость её продукта и проссумировать. уровень вложенности неизвестен, простой икл не сработает.
// Компоновщик предлагае рассматривать продукт и коробку через 1 интерфейс с общим методом получения стоимости.
// В жтом подходе создаем дерево, проходим каждому узлу дерева, прибавляя стоимость. т.е. делаем обычный обход дерева.

// Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».
// декоратор заменяет наследование на агрегацию-декомпозиции. Это когда 1 объект содержит ссылку на другой и делегирует ему работу, вместо того, чтобы наследовать его поведение.
// Аналогия из жизни. Есть класс человек. После того, как он одел свитер, он остался человеком, при этом получил защиту от холода.

// Тут есть класс, производящий продукты. Сами экзмепляры продуктов не создаем.
// Есть класс скутер и велосипед которые реализуют интерфейс Drive. Каждый класс реализовавает интерфейс по разному.
// Суть в том, что не создаем напрямую эекзмляры класса скутер, велосипед.
// Мы делаем абстрактный класс(не может быть экземпляров c 1 абстрактным методом) VichleFactory у которого есть класс-наследник, имеющйи метод GetVichle.
// Теперь, чтобы расширить, добавить пароход, нужно сделать класс параход, унаследовать интерфейс IFactory и в классе Concrevichlefactory добавить обработку на случай ship

// Фасад — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.
// Когда есть много объектов некоторой сторонней библиотеки или фреймворка. Нужно самостоятельно правильно инициализировать эти объекты, что сложно.
// Решение
// Фасад хорошо когда мы исопльзуем большую библиотеку, но нам нужна только часть её возможностей
// Аналогия из жизни: Делаем заказ по телефону. Сотрудник магазина является фасадом, предоставляющим упрощенный доступ ко всем службам и отделам магазина(создание, оплата, доставка заказа).
// У нас есть какие-то классы: CarModel, CarEnjine, ... Есть класс CarFacade в котором есть экзмпляры других классов. И есть метод, создающий машинку, готовую, используя экзмпляры класса.
// Можно исопльзовать не все экземпляры класса.

// interpeter - специфический, используется при разработке софта для программистов.
// этот шаблон может интерпертировать и записывать выражения языка

// Посредник — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.
// Аналогия из жизни. Пилоты садящихся и улетающих самолетов не связываются друг с другом. Они связываются с диспетчером, который координирует их действия. Диспетчер не нужен пилотам во время всего полета,
// только во время взлета и посадки.
// Так например, у пользователя есть 5 кнопок, которые должны взаимодейстовать между собой. Так, например, чекбокс «у меня есть собака» открывает скрытое поле для ввода имени домашнего любимца, а клик
// по кнопке отправки запускает проверку значений всех полей формы. Если пропишем эту логику в коде элементов упраления, их плохо будет использовать в других местах приложения.
// Паттерн посредник заствляет объекты не напрямую общаться друг с другом, а через отдельный объект-посредник, который знает кому нужно перенаправить запрос.
// Т.е. если есть 3 чекбокс(с галочками) и при установке галочки на другой чекбокс, не надо прописывать к чекбокс_клик взаимодействие с другими. Вместо этого создать отедный класс, который будет изменять
// значения checkbox.checked . Т.е. просто сообщаем классу что пользователь кликнул.

// Снимок — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.
// Пусть пишем программу текстового редактора. Есть операция отмены. ДЛя этого, нужно раз в какое-то время сохранять состояние файла. Плохо: создать ещё 1 класс, сохраняющий все public поля исходного класс.
// Но что делать с private полями? Хорошо - сам класс редактор делает копию всех полей. А ему доступны даже private поля.
// НАпример, класс Editor(поля id, text, cursor. методы makeSnapsoh, restore ...) Метод shapshot делает копию только состояние нужных полей. методы, св-ва хранить не надо.
// И хранин ддату кгда он был сделан.

// Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.
// Пусть есть какой-то объект, который надо скопировать. Да, можно создать объект тогоже класса и поочередно скопировать все поля. А что если эти поля private?
// Паттерн Прототип поручает создание копий самим копируемым объектам. Он вводит общий интерфейс для всех объектов, поддерживающих клонирование. Это позволяет копировать объекты, не привязываясь к их
// конкретным классам. Обычно такой интерфейс имеет всего один метод clone.
// Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта. Так получится скопировать даже приватные поля.

// Заместитель — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному
// объекту, позволяя сделать что-то до или после передачи вызова оригиналу.
// Платёжная карточка — это заместитель пачки наличных. И карточка, и наличные имеют общий интерфейс — ими можно оплачивать товары. Для покупателя польза в том, что не надо таскать с собой тонны
// наличных, а владелец магазина рад, что ему не нужно делать дорогостоящую инкассацию наличности в банк — деньги поступают к нему на счёт напрямую.
// Создали ещё 1 прокси-класс с таким же функционалом как у RealClient. Теперь клиент работает с нашим классом прокси, а класс прокси вызывает методы из RealClient.
// Нужно это для того чтобы создавать объект класса, который наследует базовый, при этом имеет ещё какую-то функциональность и контроль доступа.

// Одиночка — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
// Например строка подключения к ьд. Если мы пропишем подключение к бд в конструкторе, то каждый раз при создании объекта будет срабатывать это подключение.
// А вот если мы этот конструктор сделаем static, то вне зависимости от того, сколько объектов создадим, static конструктор вызовется 1 раз.

// Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.
// Аналог из жизни. У вас есть телефон. Телефон может быть в разном состоянии заблокирован, разблокирован, разряжен. В зависимости тот своего состояния он будет по разному реаировать на клики.
// Проблема. Состояний может быть много. Перебирать ответ на децствие в тако-то состоянии можно при помощи switch, if. Но если нам надо добавить еще 5 состояний, это будет плохо если в тот же switch
// все прописать
// Решение. Хранить не код состояния объекта, а классы состояний в котором может пребывать объект. Исходный объект будет содержать ссылку на 1 из объектов состояний
// В отличие от паттерна стратегия, тут классы состояний могу знать друг о друге и иницировать переход из одного состояния в другое.
// Есть класс state и несколько его наследников. Есть класс Account, который управляет состояниями. В зависимости от того, сколько денег на счету, выводятся разные состояния.

// Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять
// прямо во время исполнения программы.
// Аналогия из жизни. Надо добравться до жд вокзала от дома. Можно этот путь преодолеть на велосипеде, атобусе, метро, такси. В зависимости от количества времени до поезда, денег и тд мы веберем тот или
// иной подход.
// проблема. Есть приложение навигатор. В 1-й версии он может прокладывать только автомобильные маршруты. Во 2-й ещё пешеходные. В 3-й для ОТ. С каждым новым алгоритом код основного класса увеличивается
// в 2 раза.
// Решение. Паттерн Стратегия предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести их в собственные классы, называемые стратегиями.
// В данном примере каждая тратегия сортирует по разному.

// Шаблонный метод — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам
// переопределять шаги алгоритма, не меняя его общей структуры.
// Аналогия из жизни. На заводе собирают автомобили. На каждом этапе сборки можно что-то добавить, чтобы сделать автомобиль не похожим на другие. 
// Строители строят дом. Для того надо сначала залить фунумент, построить стены, крышу вставить окна. Но можно поставить на фундамент какой-то готовый дом со стенами, окнами и тд. Т.е. это не типовой дом.	

// Посетитель — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.
// Аналогия из жизни. Страховой агент прихолит на завод, банк, в дом с разными предложениями. Для завода он предлагает страховку от пожара и наводнения. Для банка он предлагает страховку от грабежа.
// Для дома он предлагает медицинскую страховку для всей семьи
// Проблема. Есть граф, в котором известны длинны дуг. Каждый узел представляет отдельный класс. Чтобы поместить этот граф в XML надо в каждом узле прописать метод toXML. Это плохо.
// Хорошо. Новое поведение размещаем в отдельном классе вместо того чтобы добавлять метод toXML в каждом из классов.